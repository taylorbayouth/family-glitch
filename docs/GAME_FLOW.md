# Game Flow Documentation

This document describes the current gameplay flow implemented in `/play`.

## Overview

Family Glitch is pass-and-play:
- Questions are preloaded during the pass screen.
- A player taps a full-screen button to reveal their turn.
- **Act 1 (first 33%)**: AI asks questions using input templates to learn about the family. Questions must NOT test memory since answers are hidden.
- **Acts 2-3 (remaining 67%)**: AI triggers mini-games based on what it learned. Mini-games test knowledge of other players' answers.
- Commentary is shown after each turn with a manual "Pass to {next}" button.
- End-game results are generated by `/api/announcer`.

## Flow Diagram

```
Setup (/setup)
  -> Pass Screen (preload AI question)
    -> Question Template OR Mini-Game
      -> AI Commentary
        -> Next Player (loop)
          -> EndGameResults (when isGameComplete() is true)
```

## Act System

The game is divided into 3 acts based on progress through total rounds:

- **Act 1 (0-33%)**: Data collection phase
  - AI asks questions to learn about each player
  - Uses input templates: `tpl_text`, `tpl_timed_binary`, `tpl_multiselect`, etc.
  - **Critical rule**: Questions must NOT test memory of other players' answers (those are secret)
  - Example questions: "What could you talk about for hours?" "Favorite YouTuber?" "Beatles or Stones?"

- **Act 2 (33-66%)**: Mini-game introduction
  - AI can trigger: **Trivia Challenge**, **Personality Match**, **Hard Trivia**
  - Eligibility: At least 1 completed turn from another player
  - Mini-games use data collected in Act 1

- **Act 3 (66-100%)**: All mini-games unlocked
  - AI can trigger: All Act 2 games + **Mad Libs**, **Cryptic Connection**, **The Filter**
  - More challenging games appear as family knowledge builds

Act boundaries are calculated in `lib/constants.ts` using `calculateCurrentAct()`.

## Mini-Game Handoff

When the AI returns a mini-game template type (e.g., `trivia_challenge`):

1. `/play` detects `isMiniGame(templateType)` returns true
2. Loads registry config from `lib/mini-games/registry.ts`
3. Calls `extractConfig()` to build game-specific props from AI params
4. Renders the mini-game UI component (e.g., `TriviaChallengeUI`)
5. Mini-game handles its own:
   - AI calls for generation and scoring
   - User interaction and input
   - Turn creation via `addTurn()`
   - Score calculation (0-5 points)
6. On completion, mini-game calls `onComplete()` with `MiniGameResult`
7. `/play` updates player score via `updatePlayerScore()`
8. Shows AI commentary and passes to next player

All mini-games follow this 2-turn AI pattern:
- **Turn 1**: Generate puzzle/question content
- **Turn 2**: Score the player's response

## Key Files

- `app/setup/page.tsx` (player roster)
- `app/play/page.tsx` (game controller)
- `components/PassToPlayerScreen.tsx`
- `components/input-templates/*` (Act 1 templates)
- `components/mini-games/*` (Acts 2-3 mini-games)
- `components/GameHeader.tsx` (leaderboard + progress)
- `components/EndGameResults.tsx`
- `lib/ai/game-master-prompt.ts` (system prompt with act-specific guidance)
- `lib/mini-games/registry.ts` (mini-game registry)
- `lib/mini-games/eligibility.ts` (turn selection for trivia)
- `lib/constants.ts` (act calculation, game length)

## Pass Screen

- Component: `PassToPlayerScreen`
- Shows current player name and role.
- Uses a large button to unlock (no slide interaction).
- `SlideToUnlock` exists but is not used in `/play`.

## Question Preloading

`/play` calls `loadQuestion()` while the pass screen is visible. The AI response is parsed into a template config before the player unlocks the screen.

Key behavior in `loadQuestion()`:
- Calls `/api/chat` with `toolChoice: 'required'`
- Parses `response.text` as JSON
- If the template type is a mini-game, it loads the mini-game config
- Otherwise, it creates a `Turn` via `addTurn()` and stores `currentTemplate`

## Question Templates

When a standard template is returned:

- `TemplateRenderer` renders the template component.
- `tpl_player_selector` is injected with `players` and `currentPlayerId` in `/play`.
- On submit, `/play` calls `completeTurn()` and requests AI commentary (`toolChoice: 'none'`).

## Mini-Games

When a mini-game template is returned:

- `/play` uses the registry in `lib/mini-games/`.
- The mini-game UI handles its own AI calls and scoring.
- On completion, the mini-game returns a `MiniGameResult`.
- Mini-games create `Turn` entries via `addTurn()` for proper progress tracking (fixed in v1.1.1).

## Commentary Phase

- After a response or mini-game, `/play` shows a commentary screen.
- Player taps "Pass to {next}" to advance.

## End Game Results

- `/play` calls `isGameComplete()` from `useGameStore()`.
- `EndGameResults` fetches `/api/announcer` using current `players`, `turns`, `scores`, and `settings`.
- Rankings and blurbs are revealed with staged animations.

## State Summary

### Player Store

- localStorage key: `family-glitch-players`
- Stores roster data across games

### Game Store

- localStorage key: `family-glitch-game`
- Stores turns, scores, and game status
- Progress helpers:
  - `getTotalRounds()` uses `calculateTotalRounds(players.length)`
  - `getCurrentRound()` counts completed turns
  - `getCurrentAct()` maps rounds to Act I/II/III

## Avatars

Avatar images are PNGs in `public/avatars/` (1.png to 14.png). Both setup and in-game UIs use these images.
